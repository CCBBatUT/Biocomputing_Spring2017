---
layout: post
title: "Introduction to Computing and Unix"
instructor: Claire
permalink: /introduction_to_unix/
materials: files/unix.zip
---

### Today

- About this course
- Getting oriented to the linux server


#### Course goal

- Make programming a practical tool for you 

#### Why programming?

- A program is a series of tasks for a computer
- We're learning python, one of the more popular languages
- Why Python?
	- general concepts are almost universal
	- readable
	- popular
	- well-documented

#### So many benefits
- Programming is a tool to help you in your life

- Repeatability
	- a script can be a record of what happened
	- this is important when things go wrong
- Automation/Efficiency
	- do the same things many times
        - avoid time spent doing repetitive manual tasks
        - Almost anything on the computer that you do repeatedly and manually can be replaced by helpful programs 
- Many tasks in today's biology require it (ex. sequence data, plotting, data analysis)


#### Why Linux?
- We'll be using a Linux server for this course
- This is essentially a file system that you connect to and navigate using text commands
- <strong>Windows</strong> users should download PuTTY.exe from <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">here</a>.
- You can only run many programs through the linux command line
- Linux makes performing operations on multiple files easier than doing by hand
       - Ex. renaming and moving files, running programs, replacing text. 
- You need to be able to navigate around in linux to use TACC

<br>
A note on backups: *Everyone should back up their computer regularly*. We will discuss some commands
today that can remove files, or even your entire file system if you are not careful.


### Getting started

- Your username is most likely likely your tacc username
- On PC, open a Putty Window 
          - fill in gsafcomp01.ccbb.utexas.edu and click 'connect'?
          - enter your username and password (most likely your TACC credentials)

- On Mac, open a terminal window
          - On the command line type: ssh [yourusername]@gsafcomp10.ccbb.utexas.edu 
          - Hit enter, and enter your password at the prompt.
          - If it asks about saving an RSA key, type 'y' or 'yes'


### Orientation
- Our class working directory is /stor/work/BioComputing2017 
- We'll use this directory for distributing files and giving examples
- Everyone has their own home directory (/stor/home/[username]). Mine is /stor/home/cmcwhite  
- You'll do all your programming and file making in your home directory - it's your sandbox

## The server file system
- The computer contains a nested hierarchy of directories
- **directory** is a *folder* on your computer which contains files
- highest level is the **root** (denoted: `/`)
- forward slashes divide levels in the nested hierarchy of directories, e.g. `/top_level_directory/second_level_directory`



### Examples of linux commands

Command | Translation | Examples
--------|-------------|---------
`cd` | **c**hange **d**irectory | `cd /absolute/path/of/the/directory/` <br> Go to the home directory by typing simply  `cd` or `cd ~` <br> Go up (back) a directory by typing `cd ..`
`pwd` | **p**rint **w**orking **d**irectory | `pwd`
`mkdir` | **m**ake **dir**ectory | `mkdir newDirectory` creates newDirectory in your current directory <br> Make a directory one level up with `mkdir ../newDirectory`
`cp` | **c**o<b>p</b>y | `cp file.txt newfile.txt` (and file.txt will still exist!)
`mv` | **m**o<b>v</b>e | `mv file.txt newfile.txt` (but file.txt will *no longer* exist!)
`rm` | **r**e<b>m</b>ove | `rm file.txt` removes file.txt <br> `rm -r directoryname/` removes the directory and all files within
`ls` | **l**i<b>s</b>t | `ls *.txt` lists all .txt files in current directory <br> `ls -a` lists all files including hidden ones in the current directory <br> `ls -l` lists all files in current directory including file sizes and timestamps <br> `ls -lh` does the same but changes file size format to be **h**uman-readable <br> `ls ../` lists files in the directory above the current one
`man` | **man**ual | `man ls` opens the manual for command `ls` (use `q` to escape page)
`grep` | **g**lobal **r**egular <br> **e**xpression **p**arser |  `grep ">" seqs.fasta` pulls out all sequence names in a fasta file <br> `grep -c ">" seqs.fasta` counts the number of those sequences <br> 
`cat` | con<b>cat</b>enate | `cat seqs.fasta` prints the contents of seqs.fasta to the screen (ie stdout)
`head` | **head** | `head seqs.fasta` prints the first 10 lines of the file <br> `head -n 3 seqs.fasta` prints first 3 lines
`tail` | **tail** | `tail seqs.fasta` prints the last 10 lines of the file <br> `tail -n 3 seqs.fasta` prints last 3 lines
`wc` | **w**ord **c**ount | `wc filename.txt` shows the number of new lines, number of words, and number of characters <br> `wc -l filename.txt` shows only the number of new lines <br> `wc -c filename.txt` shows only the number of characters
`sort` | **sort** | `sort filename.txt` sorts file and prints output
`uniq` | **uniq**ue | `uniq -u filename.txt` shows only unique elements of a list <br> (must use sort command first to cluster repeats)

<br>
<br>

	
### Handy dandy shortcuts

Shortcut | Use|
----------|-----|
Ctrl + C | kills current process
Ctrl + L <br> (or `clear`) | clears screen
Ctrl + A | Go to the beginning of the line
Ctrl + E | Go to the end of the line
Ctrl + U | Clears the line before the cursor position
Ctrl + K | Clear the line after the cursor
`*` | wildcard character
tab | completes word
Up Arrow | call last command
`.` | current directory
`..` | one level up 
`~` | home
`>` | redirects stdout to a file, *overwriting* file if it already exists
`>>` | redirects stdout to a file, *appending* to the end of file if it already exists
pipe (<code>&#124;</code>) | redirects stdout to become stdin for next command

<br>





## Demo

We have a common class work directory. 

- To get there I enter


`$ cd /stor/work/BioComputing2017`



- Linux has tab completion, so if I type

$ `cd /stor/work/Bioc[tab]`, the command will expand to the match `/stor/work/BioComputing2017`

- If the tab doesn't complete right away, type [tab][tab] to see the matches

This sequence of key presses gets to the biocomputing directory
`cd /work/Bio[tab][tab]c[tab]`

-`cd` stands for 'change directory'

#### Listing out files

- To see the files in the directory enter

`$ ls`

-For file details enter 

`$ ls -l`

The leftmost column describes file permissions - who can read, write or modify a file. 
details also include who wrote each file, file size, and time the file was last modified

The `-l` is an argument for the ls command 

- To see the full list of options for a command type:

`$ man ls`

- If I want to list details of my files, with the newest files sorted first, enter

`$ ls -lt`
 
- or it would also work syntax-wise to put the options individually, like

`$ ls -l -t`

- How would you sort files by file extension? (.txt, .py, etc?)

- `ls` will also match patterns. Say I want to see only .txt files listed, enter

`$ ls *.py` 

The * means match any number of characters before .py. 

- How would you list files starting with n?

- The command to print the contents of a file is `cat`. enter

`$ cat example.py`

- To see just the top or end of a file, the commands are `head` and `tail`

` $ head example.py`
` $ tail example.py`


#### Navigation 
- You can `cd` into any of the folders.  To get back to a higher level directory type

`$ cd ../`

- The up arrow scrolls through previous commands, so you don't have to type them out again

- Everyone has their own home directory on this server. I get to mine by

`$ cd /stor/home/cmcwhite or cd $HOME` 

- The dollar sign means that `$HOME` is a variable holding a value in bash. To see the value of a variable, enter:

`$ echo $HOME`

### Interactive exercises

1. Everyone navigate to their own home directory. 

2. Everyone will need to write and save files. We'll start today using a basic text editor called 'nano' but soon 
we'll work on getting people using the more powerful text editor 'vim'

3. Take make a new file, enter 

`$ touch hello.py`
 
4. To edit the progran in a text editor, enter 

`$ nano hello.py`

5. Inside the document, type:
print("Hello World")

6. Now type `ctrl-x` to save the file, and exit the text editor.  

7. If you type `ls -l` , you can see that this file was created and contains data. 

8. To run the program, enter
`python3 hello.py`

9. To make a new directory, enter
`$ mkdir scripts`

10. To put `hello.py` in scripts, enter
`$ mv hello.py scripts/`

11. To make a copy of `hello.py`, enter
`$ cd scripts/`

`$ cp hello.py goodbye.py`

12. One of the best things about bash is the ability to quickly rename lots of files. Say I want to add a prefix to all these scripts:

`$ for f in *.py; do mv $f script_$f; done`

13. This 'sentence' reads: For each file matching the pattern `*.py`, move it to a new filename

14. You can also chop off parts of a filename. For example, adding a date to all files you made today:

`$ for f in *.py; do mv $f ${f%.py}_012217.py; done`

The ${f%.py}_012217.py means, get the filename up to the file extension .py, then add on the date and a new extension. 


## On your own exercises

1. Navigate to your home directory

2. Create a new file called `my_file.txt` (hint: use the command `touch`)

3. Make a new directory call `dir`

4. *Move* your newly created file `my_file.txt` to the new directory (do this from your home directory)

5. Navigate to this new directory, and enter the command `pwd`. 

6. Now make a duplicate copy of this file named `my_duplicate_file.txt` which should be stored in home directory itself

7. Open this file in nano or vim. Type something exciting in the file (or just copy/paste some stuff into the file), spanning several lines, and then save/close the file.

8. Use the command `wc` to determine the number of lines in your file.

9. Use the command `grep` to find which lines contain a letter/symbol/number/phrase of your choosing.

10. Delete the file `my_file.txt`.

11. Create another new directory called `a new directory`. Now enter the command `ls`. What do you see?

12. Remove the directory(ies) created under #11.

13. Use the commands `grep` and `history` (possibly with arguments!) to figure out how many times you've used the command `cd` recently.

14. Define a new variable called "variable" and assign it the value 5

15. Print this variable to stdout (hint: use the command `echo`)

16. Pipe the contents of this variable to a new file called `newfile.txt`

17. Create a new directory called "new", and navigate to this directory

18. In a *single line* of code, create three new files called `file1.txt`, `file2.txt`, `file3.csv`. Use the command `ls` to confirm that these files were created.

19. *FROM THIS DIRECTORY* (important!), enter the command `rm *.txt`, and then enter `ls`. What remains in the directory? What is missing from the directory?


#### Notes on the computer organization and getting around

- there are several high-level directories that users don't usually go into where program files are stored
	- /usr/bin
	- /usr/lib
- every file on your computer has an address; if you are going to do an operation on a file, you need its address
- **path**: the *address* to a directory or file on your computer. There are, generally, two types of paths:
	- **absolute/full path** represents the path of a given directory or file beginning at the root directory
    - **relative path** represents the path of a given directory/file relative to the working/current directory
- for example, say you have a file "my\_favorite\_file.txt" located in the directory `/stor/Biocomputing2017/files`.
	- the **full path** to this file  is `/stor/Biocomputing/files/my_favorite_file.txt`
    - the **relative path** to this file depends on where you are on the computer
        - if you're currently in the Biocompution2017 folder, the relative path would be `files/my_favorite_file.txt` 
    
*Whenever you call the full path, you can reach the file from anywhere on your computer. Relative paths will change based on your current location.*


